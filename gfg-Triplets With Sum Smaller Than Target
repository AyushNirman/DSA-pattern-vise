gfg 
Q= Triplets With Sum Smaller Than Target

// User function Template for Java
import java.util.Arrays;
class Solution {
    long countTriplets(int n, int sum, long arr[]) {
        Arrays.sort(arr);
       long res=0;
        for(int i=0;i<n-2;i++){
            int l=i+1,r=n-1;
            while(l<r){
                long s=arr[i]+arr[l]+arr[r];
                
                if(s>=sum) r--;
                else{
                    res+=r-l;
                    l++;
                }
            }
        }
        
        return res;
    }
}




Bro, here are **clean notebook-style notes** âœï¸
(Directly copy, you will understand anytime you read)

---

## âœ… **Topic:** Triplets With Sum Smaller Than Target

### ğŸ¯ **Goal**

Count how many triplets `(i, j, k)` (i<j<k) such that:

```
arr[i] + arr[j] + arr[k] < target
```

---

## ğŸ§  **Logic / Intuition**

* Sort array
* Fix first element (i loop)
* Use **two pointers** for remaining two:

```
i = fixed index
left = i+1
right = n-1
```

### â­ Key Observation

If:

```
arr[i] + arr[left] + arr[right] < target
```

Then **all elements between left and right form valid triplets** âœ…
because array is sorted â†’ anything smaller will also work.

So we do:

```
count += (right - left)
left++
```

Else:

```
right--
```

---

## â³ **Why Two Pointer?**

Brute = O(nÂ³) âŒ
Two pointer reduces to **O(nÂ²)** âœ…

Sorted array helps decide movement:

* Sum < target â†’ move `left++` to get bigger sum
* Sum â‰¥ target â†’ move `right--` to reduce sum

---

## âœï¸ **Pseudo-notes**

```
Sort array
count = 0

For i = 0 to n-3:
    left = i+1
    right = n-1

    while(left < right):
        sum = arr[i] + arr[left] + arr[right]

        if sum < target:
            count += (right - left)
            left++
        else
            right--

Return count
```

---

## ğŸ‘€ **Example**

Input:

```
arr = [-2, 0, 1, 3], target = 2
```

Sorted â†’ `[-2, 0, 1, 3]`

| i | left,right | triplet | sum | action                  |
| - | ---------- | ------- | --- | ----------------------- |
| 0 | 1,3        | -2,0,3  | 1   | 1<2 â†’ count+=2 â†’ left++ |
|   | 2,3        | -2,1,3  | 2   | not <2 â†’ right--        |
| 1 | 2,3        | 0,1,3   | 4   | >2 â†’ right--            |

Total valid triplets = **2**

---

## ğŸš¦ **Remember**

* Sorted â†’ two pointer works
* When sum < target â†’ add `(right-left)` not just 1
* Move `left++` after counting
* Else `right--`

---

## ğŸ§© **Pattern**

Same two-pointer pattern used in:

| Problem          | Concept                   |
| ---------------- | ------------------------- |
| 3-Sum            | find triplets = target    |
| 3-Sum closest    | closest to target         |
| Triplets smaller | count triplets < target âœ… |

Master this pattern ğŸ’¯

---

### ğŸ§  **Interview Sound-bite**

> We sort, fix one number, use two pointers to count all valid triplets in O(nÂ²).
> Key idea: if arr[i] + arr[l] + arr[r] < target â†’ all values between l and r also valid.

---

## ğŸ•’ Complexity

* **Time:** O(nÂ²)
* **Space:** O(1)












