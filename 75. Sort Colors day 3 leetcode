class Solution {
    public void sortColors(int[] nums) {
        int n=nums.length;

        int low=0,mid=0,high=n-1;
        while(mid<=high){
            if(nums[mid]==0) {
                swap(nums,mid,low); mid++; low++;
            }
            else if(nums[mid]==1){
                mid++;
            }

            else{
              swap(nums,mid,high);high--;
            }
        }

    }

    public static void swap(int []arr,int i,int j){
        int temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
}







ðŸ“˜ Sort Colors (Dutch National Flag Algo)
ðŸŽ¯ Question

Array hai jisme sirf 0, 1, 2 hote hain.
Inko sort karna hai without using extra space and one pass.

ðŸ§  Main Logic

3 pointer use hote hain ðŸ‘‡

Pointer	Meaning
low	0 ka area banega (start)
mid	current element check
high	2 ka area banega (end)
ðŸ“ Rules

While mid <= high:

nums[mid]	Action	Reason
0	swap(mid, low), mid++, low++	0 left me jayega
1	mid++	1 already middle me sahi
2	swap(mid, high), high--	2 right me jayega (mid not ++ because swapped value check again)
ðŸ‘ï¸ Mental Dry-Run

Array: [2,0,2,1,1,0]

2 â†’ mid & high swap right

0 â†’ mid & low swap left

1 â†’ mid++

Left â†’ 0s | Mid â†’ 1s | Right â†’ 2s

âœ… Points to Remember

âœ” 3 pointers: low, mid, high
âœ” Only one loop
âœ” No extra space
âœ” 2 swap wale me mid++ mat karna
âœ” Classic Dutch National Flag Algorithm

ðŸ’¡ Why mid doesn't ++ when 2?

Because swap ke baad jo element aya mid pe,
wo check karna padta hai (ho sakta wo 0 ho)

ðŸ§© Time & Space
Time	Space
O(n)	O(1)
âœ… Your Code

(Perfect hai â€” Dutch algo ka clean version)
